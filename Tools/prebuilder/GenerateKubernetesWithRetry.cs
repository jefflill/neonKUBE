//-------------------------------------------------------------
// FILE:	    GenerateKubernetesWithRetry.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:	Copyright (c) 2005-2022 by neonFORGE LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using k8s;

using Neon.Common;

namespace Prebuilder
{
    /// <summary>
    /// Generates a wrapper for the <see cref="Kubernetes"/> client class, including
    /// additional retry logic.
    /// </summary>
    public static class GenerateKubernetesWithRetry
    {
        /// <summary>
        /// Implements the <b>kubernetes-wrapper</b> class.
        /// </summary>
        /// <param name="commandLine">The command line.</param>
        public static void Run(CommandLine commandLine)
        {
            const string wrapperClassName = "KubernetesWithRetry";

            var targetPath      = commandLine.Arguments.ElementAtOrDefault(0);
            var targetNamespace = commandLine.Arguments.ElementAtOrDefault(1);
            var kubernetesType  = typeof(Kubernetes);

            if (string.IsNullOrEmpty(targetPath))
            {
                Console.Error.WriteLine("*** ERROR: TARGET-PATH argument is required.");
                Program.Exit(1);
            }

            if (string.IsNullOrEmpty(targetNamespace))
            {
                Console.Error.WriteLine("*** ERROR: NAMESPACE argument is required.");
                Program.Exit(1);
            }

            // The stock [Kubernetes] class implements the [IKubernetes] interface and the
            // [KubernetesExtensions] class then adds a very large number of additional
            // methods.  We need to wrap both the interface and extension methods.

            // We're going to write the generated source to a [StringBuilder] and then
            // compare the results to the target file and only write when there's a
            // change.  This will help mitigate SSD wear when Visual Studio compiles
            // in the background.

            var sbSource = new StringBuilder();

            using (var writer = new StringWriter(sbSource))
            {
                //-------------------------------------------------------------
                // Generate the file header and opening namespace statement as well
                // as the opening class definition.

                writer.WriteLine(
$@"//-------------------------------------------------------------
// FILE:	    {Path.GetFileName(targetPath)}
// CONTRIBUTOR: Auto-generated by [prebuilder] tool during pre-build event
// COPYRIGHT:	Copyright (c) 2005-2022 by neonFORGE LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// #######################################
// # WARNING: DO NOT EDIT THIS MANUALLY! #
// #######################################
//
// This file is automatically generated during the build
// by the [prebuilder] tool.

#pragma warning disable CS1591  // Disable missing XML comment warnings

using System;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

using k8s;
using k8s.Autorest;

using Neon.Common;
using Neon.Retry;

namespace {targetNamespace}
{{
    /// <summary>
    /// Wraps the standard <see cref=""Kubernetes""/> class by adding support for an
    /// <see cref=""IRetryPolicy""/> for all instance method calls.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This is intended to be a drop-in replacement for the <see cref=""Kubernetes""/> class,
    /// adding support for an optional <see cref=""IRetryPolicy""/> for all instance method calls.
    /// </para>
    /// <para>
    /// To use, simply instantiate an instance and assign your custom <see cref=""IRetryPolicy""/>
    /// to the <see cref=""RetryPolicy""/> property.  This property defaults to <see cref=""NoRetryPolicy""/>
    /// which means this class will work exactly like the standard <see cref=""Kubernetes""/> class.
    /// You may change the retry policy at any time. 
    /// </para>
    /// <note>
    /// Static methods don't honor the retry policy.
    /// </note>
    /// </remarks>
    public sealed partial class {wrapperClassName} : IKubernetes
    {{");
                //-------------------------------------------------------------
                // Static members

                writer.WriteLine($"        //---------------------------------------------------------------------");
                writer.WriteLine($"        // Static members");
                writer.WriteLine();
                writer.WriteLine($"        private static bool isInitialized = false;");

                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Static constructor.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        static {wrapperClassName}()");
                writer.WriteLine($"        {{");
                writer.WriteLine($"            Initialize();");
                writer.WriteLine($"        }}");

                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Returns a disconnected client used for specialized situations where a Kubernetes client");
                writer.WriteLine($"        /// instance is required but it won't actually be used.  The instance returned is not actually");
                writer.WriteLine($"        /// connected to a cluster.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        public static IKubernetes CreateDisconnected()");
                writer.WriteLine($"        {{");
                writer.WriteLine($"            return new {wrapperClassName}();");
                writer.WriteLine($"        }}");


                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Handles initialzation of the stock <see cref=\"Kubernetes\"/> client's JSON serializer to");
                writer.WriteLine($"        /// support <see cref=\"JsonStringEnumMemberConverter\"/> and perhaps customize other settings.  This");
                writer.WriteLine($"        /// is required to support our custom resources.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        public static void Initialize()");
                writer.WriteLine($"        {{");
                writer.WriteLine($"            if (isInitialized)");
                writer.WriteLine($"            {{");
                writer.WriteLine($"                return;");
                writer.WriteLine($"            }}");
                writer.WriteLine();
                writer.WriteLine($"            var kubernetesJsonType = typeof(KubernetesJson).Assembly.GetType(\"k8s.KubernetesJson\");");
                writer.WriteLine();
                writer.WriteLine($"            System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(kubernetesJsonType.TypeHandle);");
                writer.WriteLine();
                writer.WriteLine($"            var member  = kubernetesJsonType.GetField(\"JsonSerializerOptions\", BindingFlags.Static | BindingFlags.NonPublic);");
                writer.WriteLine($"            var options = (JsonSerializerOptions)member.GetValue(kubernetesJsonType);");
                writer.WriteLine();
                writer.WriteLine($"            options.Converters.Add(new JsonStringEnumMemberConverter());");
                writer.WriteLine();
                writer.WriteLine($"            isInitialized = true;");
                writer.WriteLine($"        }}");

                //-------------------------------------------------------------
                // Instance members

                writer.WriteLine();
                writer.WriteLine($"        //---------------------------------------------------------------------");
                writer.WriteLine($"        // Instance members");
                writer.WriteLine();

                //-------------------------------------------------------------
                // Generate the local fields

                writer.WriteLine($"        private Kubernetes k8s;");

                //-------------------------------------------------------------
                // Generate the public constructors.

                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Private constructor that creates a special non-functional client instance");
                writer.WriteLine($"        /// that is not actually connected to a cluster.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        private {wrapperClassName}()");
                writer.WriteLine($"        {{");
                writer.WriteLine($"        }}");


                writer.WriteLine();
                writer.WriteLine($"        public {wrapperClassName}(Kubernetes k8s)");
                writer.WriteLine($"        {{");
                writer.WriteLine($"            Covenant.Requires<ArgumentNullException>(k8s != null, nameof(k8s));");
                writer.WriteLine();
                writer.WriteLine($"            this.k8s = k8s;");
                writer.WriteLine($"        }}");

                foreach (var constructor in kubernetesType.GetConstructors())
                {
                    var parameters = constructor.GetParameters();
                    var obsolete   = constructor.GetCustomAttribute<ObsoleteAttribute>();

                    writer.WriteLine();

                    if (obsolete != null)
                    {
                        if (string.IsNullOrEmpty(obsolete.Message))
                        {
                            writer.WriteLine($"        [Obsolete]");
                        }
                        else
                        {
                            writer.WriteLine($"        [Obsolete(\"{obsolete.Message}\")]");
                        }
                    }

                    writer.WriteLine($"        public {wrapperClassName}({GetParameterDefinition(parameters)})");
                    writer.WriteLine($"        {{");
                    writer.WriteLine($"            k8s = new Kubernetes({GetParameterNames(parameters)});");
                    writer.WriteLine($"        }}");
                }

                //-------------------------------------------------------------
                // Generate the [RetryPolicy] properties.

                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// <para>");
                writer.WriteLine($"        /// The retry policy to be applied public instance method calls.  This may");
                writer.WriteLine($"        /// be modified at anytime and defaults to <see cref=\"NoRetryPolicy\"/>.");
                writer.WriteLine($"        /// </para>");
                writer.WriteLine($"        /// <note>");
                writer.WriteLine($"        /// You may also set this to <c>null</c> which is equivalant to <see cref=\"NoRetryPolicy\"/>.");
                writer.WriteLine($"        /// </note>");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        public IRetryPolicy RetryPolicy {{ get; set; }} = NoRetryPolicy.Instance;");
                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Returns the <see cref=\"RetryPolicy\"/> or <see cref=\"NoRetryPolicy.Instance\"/> when the current policy is <c>null</c>.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        private IRetryPolicy NormalizedRetryPolicy => RetryPolicy ?? NoRetryPolicy.Instance;");

                //-------------------------------------------------------------
                // Generate the [Dispose()] method.

                writer.WriteLine();
                writer.WriteLine($"        /// <inheritdoc/>");
                writer.WriteLine($"        public void Dispose()");
                writer.WriteLine($"        {{");
                writer.WriteLine($"             k8s.Dispose();");
                writer.WriteLine($"        }}");

                //-------------------------------------------------------------
                // Generate the public [Kubernetes] class properties.  These are simply going to
                // reference the corresponding underlying [k8s] field's properties.

                foreach (var property in kubernetesType.GetProperties())
                {
                    var getter          = property.GetGetMethod() != null;
                    var setter          = property.GetSetMethod() != null;
                    var getterAndSetter = getter && setter;

                    writer.WriteLine();
                    writer.WriteLine("         /// <inheritdoc/>");

                    if (getterAndSetter)
                    {
                        writer.WriteLine($"        public {ResolveTypeReference(property.PropertyType, isResultType: true)} {property.Name}");
                        writer.WriteLine($"        {{");
                        writer.WriteLine($"            get => k8s.{property.Name};");
                        writer.WriteLine($"            set => k8s.{property.Name} = value;");
                        writer.WriteLine($"        }}");
                    }
                    else if (getter)
                    {
                        writer.WriteLine($"        public {ResolveTypeReference(property.PropertyType, isResultType: true)} {property.Name} => k8s.{property.Name};");
                    }
                    else if (setter)
                    {
                        writer.WriteLine($"        public {ResolveTypeReference(property.PropertyType, isResultType: true)} {property.Name} => k8s.{property.Name} = value;");
                    }
                    else
                    {
                        Covenant.Assert(false);
                    }
                }

                //-------------------------------------------------------------
                // Generate wrappers for the public static methods.

                foreach (var method in kubernetesType.GetMethods(BindingFlags.Public | BindingFlags.Static))
                {
                    var parameters = method.GetParameters();

                    writer.WriteLine();
                    writer.WriteLine($"        /// <inheritdoc/>");
                    writer.WriteLine($"        public static {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)})");
                    writer.WriteLine($"        {{");

                    if (method.ReturnType == typeof(void))
                    {
                        writer.WriteLine($"            {ResolveTypeReference(kubernetesType)}.{method.Name}({GetParameterNames(parameters)});");
                    }
                    else
                    {
                        writer.WriteLine($"            return {ResolveTypeReference(kubernetesType)}.{method.Name}({GetParameterNames(parameters)});");
                    }

                    writer.WriteLine($"        }}");
                }

                //-------------------------------------------------------------
                // Generate the [GetEnhancedHttpOperationException()] method

                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Returns a <see cref=\"HttpOperationException\"/> by including the response");
                writer.WriteLine($"        /// content in the exception message.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        /// <param name=\"e\">The original exception.</param>");
                writer.WriteLine($"        private static HttpOperationException GetEnhancedHttpOperationException(HttpOperationException e)");
                writer.WriteLine($"        {{");
                writer.WriteLine($"            return new HttpOperationException($\"{{e.Message}}\\r\\n\\r\\nRESPONSE.CONTENT:\\r\\n\\r\\n{{e.Response.Content}}\", e.InnerException)");
                writer.WriteLine($"            {{");
                writer.WriteLine($"                Response = e.Response");
                writer.WriteLine($"            }};");
                writer.WriteLine($"        }}");

                //-------------------------------------------------------------
                // Generate wrappers for the public [Kubernetes] instance methods and the [KubernetesExtensions] static methods.

                foreach (var sourceType in new Type[] { kubernetesType, typeof(KubernetesExtensions) }) 
                {
                    var generatingExtensions = false;
                    var methods              = (IEnumerable<MethodInfo>)null;

                    if (sourceType == kubernetesType)
                    {
                        generatingExtensions = false;
                        methods               = sourceType.GetMethods(BindingFlags.Public | BindingFlags.Instance);

                    }
                    else
                    {
                        generatingExtensions = true;
                        methods              = sourceType.Assembly.GetExtensionMethodsFor(typeof(IKubernetes));
                    }

                    foreach (var method in methods)
                    {
                        var parameters = method.GetParameters();
                        var isAsync    = method.ReturnType == typeof(Task) || method.ReturnType.ToString().StartsWith("System.Threading.Tasks.Task`");
                        var isOverride = false;
                        var @override  = string.Empty;
                        var obsolete   = method.GetCustomAttribute<ObsoleteAttribute>();

                        if (generatingExtensions)
                        {
                            // We're only going to generate extension methods whose first
                            // parameter type is [IKubernetes] (just to be safe).

                            if (parameters.Length < 0 || parameters.First().ParameterType != typeof(IKubernetes))
                            {
                                continue;
                            }

                            // Remove the first parameter since it'll be implicit here.

                            parameters = parameters.Skip(1).ToArray();
                        }

                        if (method.Attributes.HasFlag(MethodAttributes.SpecialName))
                        {
                            // Don't generate any property getter/setter methods.

                            continue;
                        }
                        else if (method.Name == "Dispose")
                        {
                            // We already generated the [Dispose()] method above.

                            continue;
                        }

                        // $hack(jefflill): Special case inherited virtual methods.

                        switch (method.Name)
                        {
                            case "ToString":
                            case "Equals":
                            case "GetHashCode":

                                isOverride = true;
                                @override  = " override";
                                break;

                            case "GetType":

                                // We're not generating this method.
                                continue;
                        }

                        if (isAsync)
                        {
                            Covenant.Assert(!isOverride);

                            writer.WriteLine();
                            writer.WriteLine($"        /// <inheritdoc/>");

                            if (obsolete != null)
                            {
                                if (string.IsNullOrEmpty(obsolete.Message))
                                {
                                    writer.WriteLine($"        [Obsolete]");
                                }
                                else
                                {
                                    writer.WriteLine($"        [Obsolete(\"{obsolete.Message}\")]");
                                }
                            }

                            writer.WriteLine($"        public{@override} async {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)})");
                            writer.WriteLine($"        {{");

                            if (method.ReturnType == typeof(Task))
                            {
                                writer.WriteLine($"            await NormalizedRetryPolicy.InvokeAsync(");
                                writer.WriteLine($"                async () =>");
                                writer.WriteLine($"                {{");
                                writer.WriteLine($"                    try");
                                writer.WriteLine($"                    {{");
                                writer.WriteLine($"                        await k8s.{method.Name}({GetParameterNames(parameters)});");
                                writer.WriteLine($"                    }}");
                                writer.WriteLine($"                    catch (HttpOperationException e)");
                                writer.WriteLine($"                    {{");
                                writer.WriteLine($"                        throw GetEnhancedHttpOperationException(e);");
                                writer.WriteLine($"                    }}");
                                writer.WriteLine($"                }});");
                            }
                            else
                            {
                                writer.WriteLine($"            return await NormalizedRetryPolicy.InvokeAsync(");
                                writer.WriteLine($"                async () =>");
                                writer.WriteLine($"                {{");
                                writer.WriteLine($"                    try");
                                writer.WriteLine($"                    {{");
                                writer.WriteLine($"                        return await k8s.{method.Name}({GetParameterNames(parameters)});");
                                writer.WriteLine($"                    }}");
                                writer.WriteLine($"                    catch (HttpOperationException e)");
                                writer.WriteLine($"                    {{");
                                writer.WriteLine($"                        throw GetEnhancedHttpOperationException(e);");
                                writer.WriteLine($"                    }}");
                                writer.WriteLine($"                }});");
                            }
                        }
                        else
                        {
                            writer.WriteLine();
                            writer.WriteLine($"        /// <inheritdoc/>");

                            if (obsolete != null)
                            {
                                if (string.IsNullOrEmpty(obsolete.Message))
                                {
                                    writer.WriteLine($"        [Obsolete]");
                                }
                                else
                                {
                                    writer.WriteLine($"        [Obsolete(\"{obsolete.Message}\")]");
                                }
                            }

                            writer.WriteLine($"        public{@override} {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)})");
                            writer.WriteLine($"        {{");

                            if (method.ReturnType == typeof(void))
                            {
                                if (isOverride)
                                {
                                    writer.WriteLine($"            k8s.{method.Name}({GetParameterNames(parameters)});");
                                }
                                else
                                {
                                    writer.WriteLine($"            NormalizedRetryPolicy.Invoke(");
                                    writer.WriteLine($"                () =>");
                                    writer.WriteLine($"                {{");
                                    writer.WriteLine($"                    try");
                                    writer.WriteLine($"                    {{");
                                    writer.WriteLine($"                        k8s.{method.Name}({GetParameterNames(parameters)});");
                                    writer.WriteLine($"                    }}");
                                    writer.WriteLine($"                    catch (HttpOperationException e)");
                                    writer.WriteLine($"                    {{");
                                    writer.WriteLine($"                        if (e.Response == null || string.IsNullOrEmpty(e.Response.Content))");
                                    writer.WriteLine($"                        {{");
                                    writer.WriteLine($"                            throw;");
                                    writer.WriteLine($"                        }}");
                                    writer.WriteLine();
                                    writer.WriteLine($"                        throw GetEnhancedHttpOperationException(e);");
                                    writer.WriteLine($"                    }}");
                                    writer.WriteLine($"                }});");
                                }
                            }
                            else
                            {
                                if (isOverride)
                                {
                                    writer.WriteLine($"            return k8s.{method.Name}({GetParameterNames(parameters)});");
                                }
                                else
                                {
                                    writer.WriteLine($"            return NormalizedRetryPolicy.Invoke(");
                                    writer.WriteLine($"                () =>");
                                    writer.WriteLine($"                {{");
                                    writer.WriteLine($"                    try");
                                    writer.WriteLine($"                    {{");
                                    writer.WriteLine($"                        return k8s.{method.Name}({GetParameterNames(parameters)});");
                                    writer.WriteLine($"                    }}");
                                    writer.WriteLine($"                    catch (HttpOperationException e)");
                                    writer.WriteLine($"                    {{");
                                    writer.WriteLine($"                        if (e.Response == null || string.IsNullOrEmpty(e.Response.Content))");
                                    writer.WriteLine($"                        {{");
                                    writer.WriteLine($"                            throw;");
                                    writer.WriteLine($"                        }}");
                                    writer.WriteLine();
                                    writer.WriteLine($"                        throw GetEnhancedHttpOperationException(e);");
                                    writer.WriteLine($"                    }}");
                                    writer.WriteLine($"                }});");
                                }
                            }
                        }

                        writer.WriteLine($"        }}");
                    }
                }

                // Close the class definition.

                writer.WriteLine($"    }}");

#if DONT_NEED_THIS
                //-------------------------------------------------------------
                // Define the [IKubernetesWithRetry] interface.

                writer.WriteLine(
$@"
    /// <summary>
    /// Combines the <see cref=""IKubernetes""/> definitions with the <see cref=""KubernetesExtensions""/>
    /// into one huge interface implemented by <see cref=""{wrapperClassName}""/>.
    /// </summary>
    public interface I{wrapperClassName} : IKubernetes
    {{");
                // Generate the [IKubernetes] property definitions.

                foreach (var property in kubernetesType.GetProperties())
                {
                    var getter    = property.GetGetMethod();
                    var setter    = property.GetSetMethod();
                    var accessors = new StringBuilder();

                    if (getter != null)
                    {
                        accessors.AppendWithSeparator("get;");
                    }

                    if (setter != null)
                    {
                        accessors.AppendWithSeparator("set;");
                    }

                    writer.WriteLine();
                    writer.WriteLine($"        {ResolveTypeReference(property.PropertyType, isResultType: true)} {property.Name} {{ {accessors} }}");
                }

                // Generate the [IKubernetes] method definitions.

                foreach (var method in kubernetesType.GetMethods(BindingFlags.Public | BindingFlags.Instance))
                {
                    if (method.Attributes.HasFlag(MethodAttributes.SpecialName))
                    {
                        // Don't generate the property getter/setter methods.

                        continue;
                    }
                    else if (method.Name == "Dispose")
                    {
                        // We don't need to generate the [Dispose()] method for interfaces.

                        continue;
                    }

                    var parameters = method.GetParameters();
                    var isAsync    = method.ReturnType == typeof(Task) || method.ReturnType.ToString().StartsWith("System.Threading.Tasks.Task`");
                    var isOverride = false;
                    var @override  = string.Empty;

                    // $hack(jefflill): We don't need to generate inherited virtual methods.

                    switch (method.Name)
                    {
                        case "ToString":
                        case "Equals":
                        case "GetHashCode":

                            isOverride = true;
                            @override  = " override";
                            break;

                        case "GetType":

                            // We're not generating this method.
                            continue;
                    }

                    if (isAsync)
                    {
                        Covenant.Assert(!isOverride);

                        writer.WriteLine();
                        writer.WriteLine($"        {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)});");
                    }
                    else
                    {
                        writer.WriteLine();
                        writer.WriteLine($"        {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)});");
                    }
                }

                // Close the interface definition.

                writer.WriteLine($"    }}");
#endif

                //-------------------------------------------------------------
                // Close the namespace definition.
                
                writer.WriteLine($"}}");
            }

            // Compare the newly generated source with the target file and update
            // the target only when it doesn't exist or there's a change.

            var source = sbSource.ToString();

            if (!File.Exists(targetPath) || !string.Equals(source, File.ReadAllText(targetPath)))
            {
                File.WriteAllText(targetPath, source);
            }
        }

        /// <summary>
        /// Some parameter names are C# reserved words and need to have and <b>@</b>
        /// sign prepended.
        /// </summary>
        /// <param name="name">The parameter name.</param>
        /// <returns>The noprmalized name.</returns>
        private static string NormalizeParameterName(string name)
        {
            switch (name)
            {
                case "namespace":   return "@namespace";
                case "continue":    return "@continue";
                default:            return name;
            }
        }

        /// <summary>
        /// Converts an array of reflected parameter info into a C# parameter
        /// definition.
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The C# parameter definition source code.</returns>
        private static string GetParameterDefinition(ParameterInfo[] parameters)
        {
            var sb = new StringBuilder();

            foreach (var parameter in parameters)
            {
                var typeReference      = ResolveTypeReference(parameter.ParameterType);
                var hasParamsAttribute = parameter.GetCustomAttribute<ParamArrayAttribute>() != null;

                if (hasParamsAttribute)
                {
                    sb.AppendWithSeparator($"params {typeReference} {NormalizeParameterName(parameter.Name)}", ", ");
                }
                else
                {
                    var defaultValueAssignment = string.Empty;

                    if (parameter.HasDefaultValue)
                    {
                        var defaultValue = parameter.DefaultValue;
                        var valueLiteral = string.Empty;

                        var type = parameter.ParameterType;

                        if (type.IsClass && defaultValue == null)
                        {
                            valueLiteral = "null";
                        }
                        else if (type.IsPrimitive || type == typeof(string) || type == typeof(Decimal) || type.IsEnum || type.FullName.StartsWith("System.Nullable`"))
                        {
                            if (type == typeof(string))
                            {
                                if (defaultValue == null)
                                {
                                    valueLiteral = "null";
                                }
                                else
                                {
                                    valueLiteral = $"\"{defaultValue}\"";
                                }
                            }
                            else
                            {
                                if (type.IsEnum)
                                {
                                    valueLiteral = $"{type.Name}.{defaultValue}";
                                }
                                else if (type == typeof(bool))
                                {
                                    valueLiteral = NeonHelper.ToBoolString((bool)defaultValue);
                                }
                                else if (defaultValue == null)
                                {
                                    valueLiteral = "null";
                                }
                                else
                                {
                                    valueLiteral = defaultValue.ToString();
                                }
                            }
                        }
                        else if (!type.IsClass)
                        {
                            valueLiteral = $"default({typeReference})";
                        }
                        else
                        {
                            // Other types can't have default values.

                            valueLiteral = null;
                        }

                        if (!string.IsNullOrEmpty(valueLiteral))
                        {
                            defaultValueAssignment = $" = {valueLiteral}";
                        }
                    }

                    sb.AppendWithSeparator($"{typeReference} {NormalizeParameterName(parameter.Name)}{defaultValueAssignment}", ", ");
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Returns the C# generic type definition for generic methods and an
        /// empty string for everything else.
        /// </summary>
        /// <param name="method">The target method.</param>
        /// <returns>The C# generic type definition.</returns>
        private static string GetGenericArgsDefinition(MethodInfo method)
        {
            // $todo(jefflill): This doesn't handle nested generic types.

            if (method.IsGenericMethod)
            {
                var genericArgs = method.GetGenericArguments();
                var sbArgs      = new StringBuilder();

                foreach (var arg in genericArgs)
                {
                    sbArgs.AppendWithSeparator(arg.Name, ", ");
                }

                return $"<{sbArgs}>";
            }
            else
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Returns the comma separated parameter names.
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The parameter names.</returns>
        private static string GetParameterNames(ParameterInfo[] parameters)
        {
            var sb = new StringBuilder();

            foreach (var parameter in parameters)
            {
                sb.AppendWithSeparator($"{NormalizeParameterName(parameter.Name)}", ", ");
            }

            return sb.ToString();
        }

        /// <summary>
        /// Returns the C# source string used to reference a type.
        /// </summary>
        /// <param name="type">The target type.</param>
        /// <returns>The type reference.</returns>
        private static string GetTypeName(Type type)
        {
            // Convert common types into their C# equivents:

            var typeName = type.FullName;

            switch (typeName)
            {
                case "System.Void":     return "void";
                case "System.Byte":     return "byte";
                case "System.SByte":    return "sbyte";
                case "System.Int16":    return "short";
                case "System.UInt16":   return "ushort";
                case "System.Int32":    return "int";
                case "System.UInt32":   return "uint";
                case "System.Int64":    return "long";
                case "System.UInt64":   return "ulong";
                case "System.Float":    return "float";
                case "System.Double":   return "double";
                case "System.String":   return "string";
                case "System.Boolean":  return "bool";
                case "System.Decimal":  return "decimal";
            }

            // We're going to use the global namespace to avoid namespace conflicts and we're
            // going to // Remove the special generic "`1...", syntax if present.

            typeName = type.ToString();

            var backTickPos = typeName.IndexOf('`');

            if (backTickPos != -1)
            {
                typeName = typeName.Substring(0, backTickPos);
            }

            if (type.IsGenericParameter)
            {
                return typeName;
            }
            else
            {
                return $"global::{typeName}";
            }
        }

        /// <summary>
        /// Resolves the type passed into a nice string taking generic types 
        /// and arrays into account.
        /// </summary>
        /// <param name="type">The referenced type.</param>
        /// <param name="isResultType">Optionally allow the <c>void</c> and related types (used for service method results).</param>
        /// <returns>The type reference as a string or <c>null</c> if the type is not valid.</returns>
        private static string ResolveTypeReference(Type type, bool isResultType = false)
        {
            if (isResultType)
            {
                if (type == typeof(void) || (type == typeof(Task)))
                {
                    // These types are all essentially a way of specifying [void].

                    return "void";
                }
                else if (type.IsGenericType)
                {
                    // We need to extract the type parameter from [Task<T>] or
                    // [ActionResult<T>] as a special case.

                    var typeRef = GetTypeName(type);

                    switch (typeRef)
                    {
                        case "Task":
                        case "ActionResult":

                            type = type.GenericTypeArguments.First();
                            break;
                    }
                }
            }

            if (type == typeof(void))
            {
                // This is not a valid member or parameter type.

                return null;
            }

            if (type.IsPrimitive || !type.IsArray && !type.IsGenericType)
            {
                return GetTypeName(type);
            }

            if (type.IsArray)
            {
                // We need to handle jagged arrays where the element type 
                // is also an array.  We'll accomplish this by walking down
                // the element types until we get to a non-array element type,
                // counting how many subarrays there were.

                var arrayDepth  = 0;
                var elementType = type.GetElementType();

                while (elementType.IsArray)
                {
                    arrayDepth++;
                    elementType = elementType.GetElementType();
                }

                var arrayRef = ResolveTypeReference(elementType);

                for (int i = 0; i <= arrayDepth; i++)
                {
                    arrayRef += "[]";
                }

                return arrayRef;
            }
            else if (type.IsGenericType)
            {
                if (type.Name.StartsWith("System.Nullable`"))
                {
                    // Special-case Nullable<T> by appending a "?".

                    var nullableType = type.GenericTypeArguments.First();

                    return $"{GetTypeName(nullableType)}?";
                }
                else
                {
                    var genericRef    = GetTypeName(type);
                    var genericParams = string.Empty;

                    foreach (var genericParamType in type.GetGenericArguments())
                    {
                        if (genericParams.Length > 0)
                        {
                            genericParams += ", ";
                        }

                        genericParams += ResolveTypeReference(genericParamType);
                    }

                    return $"{genericRef}<{genericParams}>";
                }
            }

            Covenant.Assert(false); // We should never get here.
            return null;
        }
    }
}
